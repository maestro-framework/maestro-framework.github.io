<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="title" content="Maestro" />
    <meta
      name="description"
      content="Maestro is a framework for providing rapid iteration for serverless orchestration"
    />
    <meta name="type" content="website" />
    <meta name="url" content="https://maestro-framework.github.io/" />
    <meta
      name="image"
      content="/assets/images/logos/maestro/full-on-light.png"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Torrel Moseley, Zac Klammer, John Isom" />
    <title>Maestro</title>
    <link rel="stylesheet" href="assets/css/fonts.css" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="assets/images/logos/maestro/favicon.png"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/dark.min.css"
      charset="utf-8"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="assets/scripts/application.js"></script>
  </head>
  <body>
    <div class="logo-links">
      <img
        src="assets/images/menu-on-light.png"
        alt="Maestro logo"
        id="menu-logo"
      />
      <a href="https://github.com/maestro-framework/maestro" target="_blank">
        <img
          src="assets/images/icons/github_black.png"
          alt="github logo"
          id="github-logo"
        />
      </a>
    </div>
    <nav id="site-navigation">
      <ul>
        <li>
          <a href="#home" id="home-link">HOME</a>
        </li>
        <li>
          <a href="#case-study" id="case-study-link">CASE STUDY</a>
          <nav id="case-study-mobile">
            <ul></ul>
          </nav>
        </li>
        <li>
          <a href="#our-team" id="our-team-link">OUR TEAM</a>
        </li>
      </ul>
    </nav>
    <header id="home">
      <figure>
        <img
          src="assets/images/logos/maestro/with-subtitle-on-light.png"
          alt="Maestro logo"
        />
      </figure>
    </header>
    <main>
      <section id="case-study">
        <h1>Case Study</h1>

        <nav>
          <ul></ul>
        </nav>

        <h2 id="introduction">1. Introduction</h2>
        <h3>1.1 What is Maestro?</h3>

        <p>
          The rise of serverless architectures and FaaS offerings such as AWS
          Lambda has revolutionized how companies are developing modern apps.
          The need for an orchestration layer over these architectures has
          brought about services such as AWS Step Functions. However, deploying
          apps that use Step Functions can be tedious and error-prone. Maestro
          prioritizes speed and developer productivity by automating this
          process so that the developer’s focus stays on developing their
          application’s business logic.
        </p>

        <p>
          Maestro is an open-source, easy-to-use framework for deploying
          serverless workflows using Node.js® and AWS Step Functions. Using
          Maestro aids development not only in the initial phase of a project
          but throughout the ongoing maintenance as well.
        </p>

        <h2 id="serverless">2. Serverless</h2>

        <p>
          The popularity of developing applications with a serverless approach
          is relatively new. The term “serverless“ seems to imply that servers
          are not involved in an application’s architecture, but that’s not
          accurate. The reason for the term “serverless“ is not because there’s
          an absence of servers, but because the control of the servers has been
          abstracted away and made the responsibility of the cloud provider. So
          from the perspective of the developer, there’s less need to worry
          about maintaining and scaling servers, effectively making their
          architecture serverless.
        </p>

        <p>
          Besides being a bit of a misnomer, the term “serverless“ is also a bit
          overloaded. It encompasses a few different ideas. One of these is what
          is known as Function as a Service (FaaS), or serverless functions.
        </p>

        <h3>2.1 FaaS</h3>

        <p>
          Serverless functions are meant to be small pieces of application code
          that are provisioned in response to some event. Once the event fires,
          a container is spun up in which the function will execute. After
          execution, the container will remain idle for a short amount of time
          in case there are further invocations of the function. If not, the
          container is torn down. This facilitates scaling up and down according
          to demand and only paying for the resources that are used. FaaS is so
          prevalent in serverless architectures that it is often equated with
          the term “serverless“ itself.
        </p>

        <figure>
          <img
            src="assets/images/serverless-poll.svg"
            alt="58% of developers in one poll respond that serverless to them is FaaS"
            title="Serverless Poll"
          />
          <figcaption>
            A recent poll asking developers how they view the term “serverless“
            [<a href="#reference_1" class="reference">1</a>]
          </figcaption>
        </figure>

        <h3>2.2 AWS Lambda</h3>

        <p>
          We’ll be limiting our discussion to a specific cloud provider, Amazon
          Web Services (AWS), as it is by far the most popular provider at this
          time.
        </p>

        <p>
          Amazon’s FaaS offering is known as AWS Lambda. Lambdas are deployed on
          containers that support runtimes in seven languages [<a
            href="#reference_2"
            class="reference"
            >2</a
          >]. Lambdas can be invoked by many AWS services including other
          Lambdas. They have a limited execution of 15 minutes, and any state
          associated with the execution is then lost.
        </p>

        <figure>
          <img
            src="assets/images/logos/aws/lambda.png"
            alt="AWS Lambda Logo"
            title="Lambda"
          />
          <figcaption>AWS Lambda</figcaption>
        </figure>

        <h3>2.3 Serverless Patterns</h3>

        <p>
          As serverless development is still relatively new, best practices have
          yet to be firmly established. However, there are helpful patterns that
          have emerged as developers continue to work with serverless.
        </p>

        <p>
          For example, when a Lambda is initially invoked, its container will
          have to be spun up, usually taking a few hundred milliseconds. This is
          often referred to as a “cold start”. To address this issue, there is a
          pattern called the Function Warmer, which keeps the Lambda’s container
          available for further invocations. Patterns for working with
          serverless can be grouped into five categories [<a
            href="#reference_3"
            class="reference"
            >3</a
          >].
        </p>

        <ul id="serverless-patterns">
          <li>Availability</li>
          <li>Event Management</li>
          <li>Communication</li>
          <li>Authorization</li>
          <li class="highlight">Orchestration</li>
        </ul>

        <p>
          We’ll be focusing our attention on this last group of patterns:
          Orchestration.
        </p>

        <h2 id="orchestration">3. Orchestration</h2>
        <p>
          Serverless orchestration is the act of managing the workflow between
          multiple serverless resources. To visualize what this might look like,
          let’s consider a hypothetical situation. Let’s say that we’ve been
          assigned a project to create an internal application for our company.
          The app will allow an employee to send a request to their manager,
          asking that a certain resource be provisioned. If the manager
          approves, the resource is provisioned and the employee is granted
          access. Otherwise, the employee is notified that their request has
          been denied.
        </p>

        <figure>
          <img
            src="assets/images/workflow/overview.png"
            alt="Initial components in workflow derived from task"
            title="Thin workflow"
            class="example-workflow"
          />
          <figcaption>
            Example of a serverless workflow with multiple Lambdas
          </figcaption>
        </figure>

        <p>
          Let’s say that the workflow can be implemented by representing each
          component as a Lambda. The work of each Lambda must then be
          orchestrated to ensure that the workflow executes in a meaningful way.
          How will we make sure this workflow proceeds as desired?
        </p>

        <p>
          Let’s assume the ‘Manager’ Lambda will receive an input that contains
          information about the resource being requested. What happens if that
          input is somehow malformed? An error could occur leading to the
          ‘Manager’ failing. Some form of error handling could prevent this, but
          should the ‘Manager’ validate its own input?
        </p>

        <figure>
          <img
            src="assets/images/workflow/validation.png"
            alt="Invalid input"
            class="example-workflow"
          />
          <figcaption>
            We need to consider how to handle an invalid input
          </figcaption>
        </figure>

        <h3>3.1 Orchestration Patterns</h3>

        <p>
          We could introduce a component that has the single responsibility of
          validating input. This would provide a clear separation of concerns
          and would prevent the ‘Manager’ from failing. A common orchestration
          pattern that could be helpful here is known as the ‘Proxy’ [<a
            href="#reference_3"
            class="reference"
            >3</a
          >]. The ‘Proxy’ is a Lambda that sits between two other Lambdas and
          invokes the second one when appropriate. In this case, we could insert
          a ‘Proxy’ Lambda called ‘Validator’ to help handle invalid inputs.
        </p>

        <figure>
          <img
            src="assets/images/workflow/validator.png"
            alt="Inserting a proxy lambda in front of the Manager component"
            title="Proxy Lambda"
            class="example-workflow"
          />
          <figcaption>
            Using the ‘Proxy’ pattern for validating input
          </figcaption>
        </figure>

        <p>
          Next, we need to determine how to properly branch based on the
          ‘Manager’ Lambda’s output.
        </p>

        <figure>
          <img
            src="assets/images/workflow/branching-logic.png"
            alt="Branching step after the Manager makes a decision"
            title="Branching"
            class="example-workflow"
          />
          <figcaption>How will we implement branching logic?</figcaption>
        </figure>

        <p>
          There’s another pattern we could use called the ‘Router’, which simply
          distributes the execution based on payload [<a
            href="#reference_3"
            class="reference"
            >3</a
          >]. Since the ‘Manager’ Lambda can invoke other Lambdas, we can
          implement the ‘Router’ pattern by placing the branching logic there.
          Because we’ve now written orchestration logic alongside business
          logic, the ‘Manager’ has become a bit ‘fat’.
        </p>

        <figure>
          <img
            src="assets/images/workflow/fat-manager.png"
            alt="Workflow with the Fat Manager Lambda"
            title="Fat Manager"
            class="example-workflow"
          />
          <figcaption>
            ‘Manager’ Lambda is now fat with orchestration logic
          </figcaption>
        </figure>

        <p>
          Now that we’ve taken care of branching, an attempt to provision the
          desired resource can be made. However, the provisioning of a resource
          may be risky. What if the attempt fails for some reason?
        </p>

        <figure>
          <img
            src="assets/images/workflow/provisioning-fail.png"
            alt="Failure depicted on the Provisioner component"
            title="Failed Provisioner"
            class="example-workflow"
          />
          <figcaption>The provisioning step fails…</figcaption>
        </figure>

        <p>
          We’d like to prevent the employee from having to repeat their request
          such that the workflow has to start over. To address this, we could
          once again apply the ‘Router’ pattern. This time, we’ll add logic to
          the ‘Manager’ so that it monitors the output of the ‘Provisioner’. If
          the ‘Manager’ detects that the provisioning has failed, we can have it
          invoke the ‘Provisioner’ again. But how many retries do we want to
          allow? How quickly do we want to retry? This is further orchestration
          logic that we’ll have to write into the ‘Manager’, making it even
          fatter.
        </p>

        <figure>
          <img
            src="assets/images/workflow/fatter-manager.png"
            alt="Addition of retry to the Fat Manager Orchertator Lambda"
            title="Fat Manager with Retry"
            class="example-workflow"
          />
          <figcaption>The ‘Manager’ Lambda is even fatter</figcaption>
        </figure>

        <p>
          Do any limitations exist with this implementation? The probability of
          the Lambda surpassing its execution limit is now increased if the
          ‘Manager’ monitors the ‘Provisioner’ and there are multiple retries.
          Delayed provisioning may cause the ‘Manager’ to terminate before
          determining if a retry was necessary. Further, with the orchestration
          logic of the ‘Manager’ written alongside the business logic, the
          component is overloaded resulting in poor separation of concerns.
        </p>

        <figure>
          <img
            src="assets/images/workflow/everything.png"
            alt="Overloaded Workflow"
            class="example-workflow"
          />
          <figcaption>Workflow overloaded with orchestration logic</figcaption>
        </figure>

        <p>
          The consequences of not separating concerns would be felt every time
          it’s necessary to iterate on the workflow. Business logic as well as
          orchestration logic may need to be evaluated and adapted for the
          application to grow.
        </p>

        <p>
          Perhaps refactoring is in order. Maybe it would be wise to extract the
          orchestration logic to a separate component other than the ‘Manager’.
          If that intuition seems natural, can more be done?
        </p>

        <p>
          Why not extract out an entire orchestration layer? The result would be
          a thin workflow of strictly business logic resembling the original
          workflow. The orchestration logic would be entirely on its own.
        </p>

        <figure>
          <img
            src="assets/images/workflow/orchestration-layer.png"
            alt="Diagram of only the orchestration layer in a workflow"
            title="Orchestration Layer"
            class="example-workflow"
          />
          <figcaption>
            An orchestration layer abstracted from the workflow
          </figcaption>
        </figure>

        <p>
          By implementing the application in this way, we’re able to orchestrate
          error handling, retry, and branching all in one place. When the
          business logic needs to be modified, the orchestration logic can
          likely stay the same. This can be quite valuable for a new application
          or one that simply hasn’t reached a stable state.
        </p>

        <p>
          So how would we go about extracting an orchestration layer? Creating
          and maintaining custom logic would require considerable overhead.
          Let’s explore another pattern called the ‘State Machine’ [<a
            href="#reference_3"
            class="reference"
            >3</a
          >] to see whether it might be suitable for our needs.
        </p>

        <h3>3.2 The State Machine Pattern</h3>

        <p>
          Rowan Udell, a guest on the Serverless Chats Podcast [<a
            href="#reference_4"
            class="reference"
            >4</a
          >], provides a helpful description of a state machine.
        </p>

        <blockquote cite="https://www.serverlesschats.com/16/">
          <p>
            "State machines are really just a mathematical way of modeling an
            application.…[With state machines,] you can describe your
            application as a mixture of your
            <span class="highlight">inputs</span>, the
            <span class="highlight">states</span> that your application can be
            in, and the <span class="highlight">transitions</span> between those
            states."
          </p>
          <footer>
            Rowan Udell, <cite>Serverless Chats Podcast – Episode #16</cite>
          </footer>
        </blockquote>

        <p>
          It’s important to note that a state machine is not a physical device
          but an abstract concept. A state machine is all about inputs, outputs,
          transitions, and state, making it an ideal candidate for an
          orchestration layer. But how would we go about implementing a state
          machine? It just so happens that AWS offers a “State Machine as a
          Service” called AWS Step Functions.
        </p>

        <h2 id="aws-step-functions">4. AWS Step Functions</h2>

        <p>
          Here's how Amazon describes AWS Step Functions [<a
            href="#reference_5"
            class="reference"
            >5</a
          >].
        </p>

        <blockquote
          cite="https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html"
        >
          <p>
            “AWS Step Functions is a web service that enables you to coordinate
            the components of distributed applications and microservices using
            visual workflows. You build applications from individual components
            that each perform a discrete function, or task, allowing you to
            scale and
            <span class="highlight">change applications quickly</span>.”
          </p>
          <footer>
            AWS Documentation, <cite>What is AWS Step Functions?</cite>
          </footer>
        </blockquote>

        <figure>
          <img
            src="assets/images/logos/aws/step-functions.png"
            alt="AWS Step Functions Logo"
            title="Step Functions Logo"
          />
          <figcaption>AWS Step Functions</figcaption>
        </figure>

        <p>
          Step Functions are designed to contain an application's orchestration
          logic. This helps us to maintain the separation of concerns that we
          mentioned earlier. To create a state machine with Step Functions,
          we'll need to use the JSON-based language called Amazon States
          Language (ASL).
        </p>

        <h3>4.1 Amazon States Language</h3>

        <p>
          Let's first look at a “Hello World” state machine definition to
          familiarize ourselves with ASL.
        </p>

        <figure>
          <div class="flex">
            <pre>
              <code class="js dark">
{
  "StartAt": "Hello World",
  "States": {
    "Hello World": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:WORKFLOW_NAME_hello",
      "End": true
    }
  }
}
              </code>
            </pre>
            <img
              src="assets/images/step-functions-console/hello-world.png"
              alt="Example of the ASL of a workflow for a Hello World Application"
              title="Hello World ASL "
            />
          </div>
          <figcaption>
            A state machine definition with a visual that is displayed in the
            AWS Management Console
          </figcaption>
        </figure>

        <p>
          There are two required fields for all state machines:
          <code>StartAt</code> and <code>States</code>. The
          <code>StartAt</code> field simply designates which state will begin
          execution, whereas the <code>States</code> field is a list of all
          possible states. Once a valid definition is entered in the AWS
          Management Console, a visual that represents the state machine will be
          displayed.
        </p>

        <p>
          The only state in this simple example is a <code>Task</code> state
          that is representing a Lambda function. Besides <code>Task</code>,
          several other state types can be used to help orchestrate the
          workflow.
        </p>

        <p>
          Let's return to our earlier example of an employee requesting approval
          for a resource to be provisioned. We'll now implement this workflow
          with Step Functions.
        </p>

        <figure>
          <div class="flex">
            <pre>
              <code class="js dark">
{
  "StartAt": "Requester",
  "States": {
    "Requester": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:WORKFLOW_NAME_requester",
      "Next": "Manager"
    },
    "Manager": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:WORKFLOW_NAME_manager",
      "Next": "ManagerChoice"
    },
    "ManagerChoice": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.decision",
          "StringEquals": "accept",
          "Next": "Provisioner"
        },
        {
          "Variable": "$.decision",
          "StringEquals": "deny",
          "Next": "Notifier"
        }
      ]
    },
    "Provisioner": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:WORKFLOW_NAME_provisioner",
      "Next": "AccessGranter",
      "Retry": [
        {
          "ErrorEquals": ["States.ALL"],
          "IntervalSeconds": 2,
          "BackoffRate": 1.5,
          "MaxAttempts": 5
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.errorInfo",
          "Next": "Notifier"
        }
      ]
    },
    "AccessGranter": {
      "Type": "Pass",
      "Next": "Notifier"
    },
    "Notifier": {
      "Type": "Pass",
      "End": true
    }
  }
}

              </code>
            </pre>
            <img
              src="assets/images/step-functions-console/example-workflow.png"
              alt="Visualization of example workflow in AWS Management Console"
            />
          </div>
          <figcaption>
            Earlier example now implemented with AWS Step Functions
          </figcaption>
        </figure>

        <p>
          If we look more closely at the state called <code>Provisioner</code>,
          we see how one might implement retry logic. <code>Task</code> states
          have an optional field called <code>Retry</code> that will specify
          which types of errors to retry, how many seconds to wait in between,
          as well as a backoff rate and a maximum number of attempts. It's
          useful to be able to put this orchestration concern here, instead of
          writing some custom retry logic alongside business logic.
        </p>

        <figure>
          <div class="flex">
            <pre>
              <code class="js dark">
//…
"Provisioner": {
  "Type": "Task",
  "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:provisioner",
  "Next": "AccessGranter",
  "Retry": [
    {
      "ErrorEquals": ["States.ALL"],
      "IntervalSeconds": 2,
      "BackoffRate": 1.5,
      "MaxAttempts": 5
    }
  ],
  //…
},

              </code>
            </pre>
          </div>
          <figcaption>Provisioner state showing retry logic in ASL</figcaption>
        </figure>

        <h3>4.2 Execution Event History</h3>

        <p>
          Once a state machine has executed, using the AWS Management Console,
          we're able to access an interactive execution event history. This
          allows us to audit the transitions between states in one, unified
          place.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/logs.png"
            alt="Execution event history"
          />
          <figcaption>
            Execution Event History in the AWS Management Console
          </figcaption>
        </figure>

        <p>
          Additionally, the visual workflow will be color-coded to help us
          quickly remember the outcome of each state for that execution. This
          interface is updated in real-time, which can be helpful when viewing
          the status of longer-running state machines.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/execution.png"
            alt="Visualization of an executing state machine in the AWS Management Console"
          />
          <figcaption>
            An executing state machine in the AWS Management Console
          </figcaption>
        </figure>

        <p>
          The core purpose of AWS Step Functions is to provide an orchestration
          layer, preventing us from having to somehow choreograph our
          application's resources. Step Functions also provides many built-in
          features, such as unified logs and visual workflows that can help when
          needing to audit executions.
        </p>

        <p>
          Despite these benefits, some challenges arise when choosing to develop
          with Step Functions. Let's examine some of these problems.
        </p>

        <h2 id="problems">5. Problems</h2>
        <h3>5.1 Programming Model</h3>

        <p>
          One of the common complaints with Step Functions is that ASL is not
          very intuitive.
        </p>

        <blockquote
          cite="https://www.serverless.com/aws-step-functions#drawbacks"
        >
          <p>
            Amazon States Language is quite complex; its syntax is based on JSON
            and therefore
            <span class="highlight">optimized for machine readability</span>
            instead of readability by humans.
          </p>
          <footer>
            Article from
            <cite
              >Serverless Framework [<a href="#reference_6" class="reference"
                >6</a
              >]
            </cite>
          </footer>
        </blockquote>

        <p>
          Imagine creating a state machine with dozens or even hundreds of
          states.
        </p>

        <blockquote
          cite="https://research.chalmers.se/publication/508147/file/508147_Fulltext.pdf"
        >
          <p>
            “ ‘…
            <span class="highlight"
              >Nobody wants to write JSON format for a state machine that has
              hundreds of states</span
            >.’ -Interviewee 1
          </p>
          <p>
            There is an expectation that, in the future, higher-level
            abstractions will be developed and current technologies, such as
            Lambda and Step Functions, will become mere deployment platforms,
            which are
            <span class="highlight">not intended to be programmed directly</span
            >.”
          </p>
          <footer>
            Philipp Leitner et al. –
            <cite
              >Paper from Chalmers University of Technology [<a
                href="#reference_1"
                class="reference"
                >1</a
              >]</cite
            >
          </footer>
        </blockquote>

        <p>
          Several tools attempt to provide higher-level abstractions that
          compile down to ASL. However, none has been widely adopted and there
          is still unsettled debate regarding the characteristics of these tools
          [<a href="reference_7" class="reference">7</a>].
        </p>

        <p>
          It seems that, for now, the most effective way to alleviate the pain
          of working with ASL is to use templates. This at least provides a
          useful starting point for beginners and is a nice convenience for
          those who are more familiar with the language.
        </p>

        <h3>5.2 Deployment</h3>

        <p>
          Another challenge arises in an area that isn’t unique to Step
          Functions: deploying to AWS. This is a notorious area of concern for
          developers that have to interface with a broad spectrum of AWS
          services to put their applications on the cloud.
        </p>

        <p>
          Since Step Functions is an orchestration layer, many components may be
          integrated with a single state machine and need to be deployed in
          parallel. In some cases, components may represent AWS services outside
          of and including Lambdas. Even a single state machine orchestrating a
          single Lambda component represents at least 2 separate AWS services.
        </p>

        <p>
          Each deployed component, including the state machine itself, needs to
          be accompanied by an appropriate region and account number for a
          successful deployment. Further, proper permissions must be configured.
        </p>

        <p>
          Further, there are individual interfaces for each service, so
          configuration on AWS cannot be performed in a single, shared location.
          Manual pre-deployment configuration, especially in the AWS console,
          can prove tedious and error-prone.
        </p>

        <p>
          Consider the process of creating the example workflow previously
          discussed using the AWS Console.
        </p>

        <figure>
          <img
            src="assets/images/hazy-diagrams/full.png"
            alt="Resources to be provisioned manually"
          />
          <figcaption>Resources to be provisioned</figcaption>
        </figure>

        <p>
          There are seven steps to go through to create a state machine. Several
          of the steps comprise tedious clicking around the console rather than
          intellectual challenges. However, a couple of steps could cause real
          trouble. For example, step 4 in the accompanying diagram is where ASL
          needs to be provided to create a state machine.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-1.gif"
            alt="gif of steps to create the state machine"
          />
          <figcaption>Steps to create the state machine</figcaption>
        </figure>

        <p>
          If a developer is familiar with ASL and knows what they want to
          create, this could take several minutes even when some elements of the
          code have been provided (as with a template). For a developer
          unfamiliar with ASL, properly integrating ASL could take several
          hours.
        </p>

        <p>
          After providing and modifying ASL, a developer may attempt to save the
          state machine to create other components of the application. It makes
          sense to create the orchestration layer first as it serves as a map
          for integrating components during development. Unfortunately, to the
          developer’s chagrin, they may run into an error if they don’t provide
          a valid ARN (Amazon Resource Name) for all associated state machine
          components. Most developers who aren’t familiar with writing a valid
          ARN would solve the error by navigating to the Lambda console,
          creating all of the necessary Lambdas while the Step Functions console
          remains open, and copying/pasting the ARNs of the created Lambdas into
          the state machine definition. For the experienced AWS developer, it’s
          possible to write a valid ARN for each component, but it’s another
          layer of tedium which requires exactitude to get right.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-4.gif"
            alt="State machine creation failing"
          />
          <figcaption>State machine creation failing</figcaption>
        </figure>

        <p>
          What does navigating to the Lambda console and creating the pertinent
          Lambdas look like? It’s another series of five steps the most
          difficult of which is providing the business logic for the Lambda
          (represented by the third step in the following diagram).
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-3.gif"
            alt="Steps for creating a single Lambda function"
          />
          <figcaption>
            Step to create a Lambda function in the AWS Console
          </figcaption>
        </figure>

        <p>
          The difficulty regarding the AWS console is that every step, large and
          small, needs to be performed for each Lambda.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-2.gif"
            alt="Creating all 4 lambda functions"
          />
          <figcaption>
            Step to create a Lambda function in the AWS Console
          </figcaption>
        </figure>

        <p>
          After each lambda has been created, only then can the state machine be
          saved.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-5.gif"
            alt="finishing up the state machine"
          />
          <figcaption>Finishing up the state machine</figcaption>
        </figure>

        <p>
          Adding these five steps for each of the four Lambdas in our example
          workflow plus those required to create the state machine totals 28
          steps. The time required to accomplish these steps with existing
          business logic and a template for the ASL would vary between several
          minutes and several hours depending on the developer’s skill working
          with the console.
        </p>

        <p>
          A question to note regarding developing in the AWS console is whether
          it would mirror the typical development workflow of a software
          engineer who customarily works in a familiar local environment and
          later deploys? Would a developer not prefer opening all application
          files in their local text editor and deploying through a single
          interface?
        </p>

        <p>
          What if a developer implements the components locally? There are tools
          like the AWS SDK and AWS CLI that allow the developer to create an
          interface between a local machine and the AWS cloud. Writing the
          necessary orchestration code and business logic using either or both
          of those tools takes time to learn, and deploying the components to
          AWS continues to pose configuration challenges like those previously
          mentioned.
        </p>

        <figure>
          <img
            src="assets/images/aws-services-diagram.png"
            alt="The AWS Console has many interfaces"
          />
          <figcaption>
            The AWS Console has a separate interface for each service
          </figcaption>
        </figure>

        <p>
          Whether implementing components in disparate AWS consoles or locally
          with the AWS SDK or AWS CLI, speed of development would certainly be
          impacted at least while getting accustomed to AWS development. There
          is a formidable learning curve.
        </p>

        <p>
          It’s easy to imagine why certain aspects of deployment could benefit
          from automation. Indeed, several frameworks aim to help the developer
          perform deployment related tasks.
        </p>

        <p>
          It’s unlikely that the first version of an application will be the
          version that stands the test of time, and for the application to
          evolve, old versions need to be torn down. This is especially true
          when working in a new, unfamiliar environment.
        </p>

        <p>
          Tearing down in the AWS Console isn’t challenging. It’s just tedious.
          It mainly involves:
        </p>

        <ul id="deletion-steps">
          <li>Navigating to a service</li>
          <li>Clicking around a bit</li>
          <li>Selecting a resource</li>
          <li>Deleting</li>
          <li>Confirming</li>
        </ul>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-6.gif"
            alt="deleting each resource one-at-a-time"
          />
          <figcaption>Deleting each resource one-at-a-time</figcaption>
        </figure>

        <p>
          Clicking around to delete the example workflow in IAM, Step Functions,
          and Lamda interfaces take some 30 steps. Deletion is a risky business,
          and selecting the wrong component to delete anywhere along the way
          requires attention; one must go slowly. Otherwise, the wrong component
          could be deleted, possibly losing valuable execution data.
        </p>

        <h2 id="existing-solutions">6. Existing Solutions</h2>

        <p>
          A framework for deploying to AWS will typically be built using one of
          two AWS tools. Let's first understand a bit about these tools before
          examining any specific frameworks.
        </p>

        <p>
          The first one we'll look at is called AWS CloudFormation [<a
            href="#reference_8"
            class="reference"
            >8</a
          >]. With this approach, a framework can guide us through a process of
          creating framework-specific files that are then compiled to a single
          CloudFormation config file. All our serverless resources can then be
          deployed using this file. Frameworks that aim to be more
          general-purpose often take the CloudFormation approach.
        </p>

        <figure>
          <img
            src="assets/images/logos/aws/cloud-formation.png"
            alt="CloudFormation Logo"
          />
          <figcaption>AWS CloudFormation</figcaption>
        </figure>

        <p>
          The other tool is the AWS Software Development Kit (SDK) [<a
            href="#reference_9"
            class="reference"
            >9</a
          >]. This is a collection of APIs that allow us to work directly with
          individual resources from our language of choice. Frameworks geared
          toward a specific use case or a particular language are usually built
          with the SDK.
        </p>

        <figure>
          <img src="assets/images/logos/aws/sdks.png" alt="AWS SDK Logo" />
          <figcaption>AWS SDK</figcaption>
        </figure>

        <p>
          Let's now examine some specific frameworks, keeping in mind that we'll
          only be considering those that support Step Functions.
        </p>

        <h3>6.1 Serverless Framework</h3>

        <p>
          The aptly named Serverless Framework [<a
            href="#reference_10"
            class="reference"
            >10</a
          >] is the dominant player in this space. It supports deployment to
          many cloud providers and in several different languages.
        </p>

        <figure>
          <img
            src="assets/images/logos/serverless-framework.png"
            alt="Serverless Framework logo"
          />
          <figcaption>Serverless Framework</figcaption>
        </figure>

        <p>
          Serverless Framework has an active community that has created over two
          thousand open-source plugins [REFERENCE]. One of these plugins enables
          support for Step Functions.
        </p>

        <p>
          There are some common state machine templates available at the bottom
          of the plugin's <code>README</code> [(check)REFERENCE]. While this is
          helpful, it would be nice to be able to create a new project based on
          a certain template without having to copy and paste from the
          <code>README</code>. Also, to accommodate Serverless Framework’s
          conventions, the state machine must be written in YAML. This is
          unfortunate since ASL is a JSON-based language.
        </p>

        <h3>6.2 AWS SAM</h3>

        <p>
          Amazon provides a framework for serverless deployment called the AWS
          Serverless Application Model (SAM) [<a
            href="#reference_11"
            class="reference"
            >11</a
          >]. SAM started providing support for Step Functions just a few months
          before this writing.
        </p>

        <figure>
          <img src="assets/images/logos/aws/sam.png" alt="AWS SAM logo" />
          <figcaption>AWS SAM</figcaption>
        </figure>

        <p>
          Unlike Serverless Framework, a working state machine can be deployed
          from a template, without having to make any manual configurations – it
          can all be done straight from the CLI. However, there is only one
          template that is offered and it has a relatively lengthy deployment
          time, taking about three minutes. There are also several prompts that
          the user must respond to during this process. Once deployed, there
          doesn’t seem to be a command that just as easily tears down, so that
          must be done manually.
        </p>

        <p>
          It's important to note that neither Serverless Framework nor SAM was
          designed with Step Functions in mind. They both later added support
          for Step Functions for apps that happens to use them. And because of
          their general-purpose nature, these frameworks carry around a lot of
          tooling, which may be unnecessary and bulky for simpler workflows.
        </p>

        <h3>6.3 Step</h3>

        <p>
          What about more purpose-built frameworks that use the SDK?
          Unfortunately, there don't seem to be many specifically designed for
          Step Functions. There is one built by Coinbase called Step, which is
          “a framework for building, testing, and deploying AWS Step Functions
          and Lambda”. [<a href="#reference_12" class="reference">12</a>].
        </p>

        <figure>
          <img src="assets/images/logos/step.png" alt="Step Logo" />
          <figcaption>Step</figcaption>
        </figure>

        <p>
          Step allows the user to construct a state machine definition with a
          higher-level language, namely Go. However, Coinbase seems to be one of
          the only users of their framework. In fact, the development status of
          the framework is listed as Beta. An additional drawback is that Step
          is not able to create a new state machine but can only modify an
          existing one. This can be a hindrance to the developer who is wanting
          to quickly iterate on their work but has to manually create a mock
          state machine first.
        </p>

        <p>
          While the above solutions provide some helpful ways to manage Step
          Functions, we found them lacking in some important areas. Because of
          this, we decided to build Maestro.
        </p>

        <h2 id="maestro">7. Maestro</h2>

        <p>
          Maestro is an open-source Node.js framework for AWS Step Functions
          built with ease of use in mind. It offers simple commands that
          facilitate common operations for applications that are suited for Step
          Functions, including interactions with AWS.
        </p>

        <p>
          Once Maestro has been installed and configured, deploying a state
          machine is a simple process. Create a new Maestro project, optionally
          edit the state machine template, and then type one command to deploy
          the state machine and any Lambda functions it includes. One could say
          that it’s as easy as 1, 2, 3.
        </p>

        <figure>
          <img
            src="assets/images/step-functions-console/console-diagram-7.gif"
            style="max-height: 50vh;"
            alt="deploying with maestro"
          />
          <figcaption>Deploying with Maestro</figcaption>
        </figure>

        <p>
          Maestro also has robust manual (man) pages which contribute to its
          ease of use. A new project can be quickly and easily created with the
          <code class="command language-plaintext">maestro new</code> command.
          Further, speed is prioritized as Maestro allows rapid deployment in
          just 3 seconds, enabling quickly bootstrapping a new project or
          iterating on an existing one. Teardown can just as quickly be
          performed in as little as 2 seconds.
        </p>

        <h3>7.1 Commands</h3>

        <table id="commands-table">
          <thead>
            <tr>
              <th>Command</th>
              <th>Description</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                <code class="command language-plaintext">
                  <pre>maestro new</pre>
                </code>
              </td>

              <td>
                <p>
                  This command creates a new Maestro project with the given
                  project name. When
                  <code class="command language-plaintext">maestro new</code> is
                  executed, the user is prompted with a list of all the
                  templates to base their new project off of.
                </p>

                <p>
                  If the user simply presses <code>&lt;return&gt;</code>at the
                  prompt or enters an invalid input, the new project is created
                  without influence ofa template.
                </p>
              </td>
            </tr>

            <tr>
              <td>
                <code class="command language-plaintext">
                  <pre>maestro deploy</pre>
                </code>
              </td>

              <td>
                <p>
                  This command must be executed at the root of your Maestro
                  project. It will deploy both the state machine as defined in
                  <code>definition.asl.json</code> and all lambda functions
                  defined in the <code>lambdas/</code> directory. If you do not
                  have the necessary Maestro IAM roles, running this command
                  will automatically create themforyou as part of the
                  deployment.
                </p>

                <p>
                  Typical deployment time is a lightning-fast
                  <em>3 seconds</em>.
                </p>
              </td>
            </tr>

            <tr>
              <td>
                <code class="command language-plaintext">
                  <pre>maestro teardown</pre>
                </code>
              </td>

              <td>
                <p>
                  Executing this command with your working directory being the
                  root of some Maestro project will tear down the associated
                  resources from AWS, which are as follows:
                </p>

                <ul>
                  <li>
                    All AWS Lambdas uploaded from the project-local
                    <code>lambdas/</code> directory.
                  </li>
                  <li>
                    The AWS Step Functions state machine created from the
                    project-local <code>definition.asl.json</code> definition
                    file.
                  </li>
                  <li>Any AWS IAM roles specified via an optional flag.</li>
                </ul>
              </td>
            </tr>

            <tr>
              <td>
                <code class="command language-plaintext">
                  <pre>maestro help</pre>
                </code>
              </td>

              <td>
                <p>
                  Display help information about Maestro or a Maestro command.
                </p>
              </td>
            </tr>

            <tr>
              <td>
                <code class="command language-plaintext">
                  <pre>maestro config</pre>
                </code>
              </td>

              <td>
                <p>
                  The
                  <code class="command language-plaintext">maestro config</code
                  >command should be the first command run after installing
                  Maestro. Any Maestro deployment or teardown depends on the
                  account information configured by this command.
                </p>
              </td>
            </tr>

            <tr>
              <td>
                <code class="command language-plaintext">
                  <pre>maestro get-templates</pre>
                </code>
              </td>

              <td>
                <p>
                  Fetches the Maestro default templates from git and installs
                  themon the user’s local machine.
                </p>
              </td>
            </tr>
          </tbody>
        </table>

        <h3>7.2 Challenges</h3>

        <p>
          One may now understand the value of working with a framework like
          Maestro, but, as with other projects, there were development
          challenges along the way.
        </p>

        <h4>7.2.1 AWS IAM</h4>

        <p>
          One source of difficulty was dealing with IAM [<a
            href="#reference_13"
            class="reference"
            >13</a
          >]. IAM is the AWS service that allows for the creation of roles that
          can operate within the AWS environment and perform tasks stipulated by
          associated permissions and policies. Authorization is often a
          challenge in most programming environments, and AWS is no exception.
        </p>

        <p>
          For those inexperienced with IAM, the initial challenge is determining
          what set of permissions and policies must be provided to allow each
          component to execute properly. One would imagine that clear
          documentation regarding which permissions and policies allow execution
          of a given task would be a major priority, but such mapping of
          permission and policy capabilities is not forthcoming.
        </p>

        <p>
          To initially determine which basic capabilities the components in a
          standard Lambda-centric workflow required, the Maestro team created
          some mock components and observed which policies AWS attached by
          default. Later, a composite of these policies was applied to Maestro
          Lambdas.
        </p>

        <p>
          Assuming that roles can be created and have the proper permissions
          with appropriate policies attached, sequencing the creation of
          services such that the roles and policies are accessible before
          attempting to associate them with a service comprises a subsequent
          challenge. Notice, the Maestro team established the creation of roles
          with policies but took for granted that those roles would be
          accessible to other services whence created.
        </p>

        <p>
          Role creation synchronously preceded any attempt to create subsequent
          resources that needed those roles, but confirming the creation of a
          role in IAM did not indicate the availability of the role for
          association with another service. Further, the most straightforward
          mechanism for determining a role’s availability in another service
          requires attempting to associate it with that service from within the
          other service. Simply accessing IAM to determine if the role exists
          says little regarding whether its existence has propagated to other
          services.
        </p>

        <p>
          Therefore, to create Lambdas and state machines with associated roles,
          the Maestro team resolved to implement retry in the chain of role
          creation and subsequent creation of services. Built-in retry does
          exist in SDKs, but such retry is for atomic retry of a service
          interaction, not the retry of the business logic of an interservice
          framework. In other words, if creating a role in IAM failed, there
          would be an AWS means of retrying that interaction, but since the
          current problem is not a failed role creation but its propagation to
          other services, the Maestro team had to roll its own retry.
        </p>

        <p>
          The retry process was fraught with further challenges since the error
          messages of unsuccessful attempts to attach a policy to a Lambda or
          state machine were quite cryptic. The AWS documentation for role
          association was not as robust as the team would have hoped, but in the
          end, retry with appropriate initial sleep and backoff rates was
          achieved.
        </p>

        <h4>7.2.2 Asynchronicity</h4>

        <p>
          Discussing the challenge of creating a Lambda or state machine with
          the ability to properly interact with AWS depending on another service
          touches on an overarching challenge that would need to be reconciled
          in developing Maestro: asynchronicity. Maestro offers quick deployment
          thanks to concurrent creation and deployment of resources which
          requires navigating numerous issues related to synchronicity.
        </p>

        <p>
          A helpful pattern that allowed the team to work with asynchronous
          functions and Promises was the ‘async/await’ pattern. This allowed
          certain actions to be treated synchronously. However, the Maestro
          philosophy was not to completely remove Promise chains by dogmatically
          applying the ‘async/await’ pattern everywhere possible. Overuse of the
          pattern can cause code to be slow by essentially making every step
          synchronous [<a href="#reference_14" class="reference">14</a>]. To
          achieve relevant concurrency in creating resources, a mixture of
          ‘Promise chains’, ‘async/await’, and
          <code class="command language-plaintext">Promise.all</code> was
          implemented. The result is a lightning-fast framework.
        </p>

        <h4>7.2.3 Domain</h4>

        <p>
          Serverless orchestration is a very niche topic. Although AWS Lambda is
          a popular service, orchestration is often done company-by-company
          without adhering to a common set of shared best practices. Navigating
          common approaches required extensive, in-depth inquiry. Further, AWS
          Step Functions offers many benefits but is not broadly used; as a
          result, few frameworks or solutions exist to provide insight into
          development. Therefore, the Maestro team had to be quite innovative to
          provide a framework in this space.
        </p>

        <h3>7.3 Future Work</h3>

        <p>
          As with most endeavors, not all that was desired could be accomplished
          from the outset. Here are a few aspirations that are left for future
          work.
        </p>

        <p>
          Ultimately, a framework that works with ASL could be benefited by
          abstracting away the awkward language. As was previously described,
          the objective of Maestro is to facilitate working with ASL through
          templates. However, no set of templates can be comprehensive, and any
          developer working extensively with Step Functions will eventually
          require writing ASL. Having an ASL ‘wrapper’ to imperatively write
          ASL, in effect, mirroring common procedural coding would be helpful.
        </p>

        <p>
          Another possible future addition would be integration with the host
          logging system. More robust logging is helpful in the event something
          goes wrong with the deployment of an individual component or an entire
          workflow.
        </p>

        <p>
          Further, if a premise of Maestro is allowing rapid iteration on
          workflows, versioning comes into view. Much consideration must go into
          determining the point at which a workflow is ready for production, and
          due to innumerable circumstances, a team may resolve to look back at
          some previous version of their application. Ideally, a version of the
          workflow would be persisted and easily accessible every time a
          workflow was newly deployed.
        </p>

        <p>
          Which brings to mind another consideration left for the future: a
          <code class="command language-plaintext">maestro redeploy</code>
          command. It would be helpful, especially for complex workflows, to
          intelligently re-deploy only elements of the workflow that have
          changed since the last version. If versioning were clearly outlined,
          then re-deploying could look back at a snapshot of the workflow to
          determine what changed and then re-deploy accordingly. This would help
          preserve artifacts in AWS that provide auditability of long-standing
          components.
        </p>

        <p>
          As clearly outlined, the current focus of Maestro is the ever-popular
          AWS Lambdas. While much can be achieved, and often is, strictly using
          Lambdas, other services offer a broader range of development
          possibilities. Having encountered a starting point for development,
          integrating further AWS services into Maestro would amplify its
          potential.
        </p>

        <p>
          Currently, the Maestro configuration depends on a single configuration
          file referenced in numerous projects. It would be beneficial to have a
          unique config file for each project allowing deployment in various
          regions and even to different AWS accounts. On a similar note, a
          developer may use different Node.js runtimes, so support for various
          versions could be added.
        </p>

        <section id="references">
          <h2>8. References</h2>

          <ol>
            <li id="reference_1">
              <a
                target="_blank"
                href="https://research.chalmers.se/publication/508147/file/508147_Fulltext.pdf"
                >A mixed-method empirical study of Function-as-a-Service
                software development in industrial practice</a
              >
            </li>
            <li id="reference_2">
              <a target="_blank" href="https://www.serverless.com/aws-lambda"
                >AWS Lambda - The Ultimate Guide</a
              >
            </li>

            <li id="reference_3">
              <a
                target="_blank"
                href="https://www.researchgate.net/publication/340121613_Patterns_for_Serverless_Functions_Function-as-a-Service_A_Multivocal_Literature_Review"
                >Patterns for Serverless Functions</a
              >
            </li>
            <li id="reference_4">
              <a target="_blank" href="https://www.serverlesschats.com/16/"
                >Serverless Workflows using Step Functions</a
              >
            </li>
            <li id="reference_5">
              <a
                target="_blank"
                href="https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html"
                >What Is AWS Step Functions?</a
              >
            </li>
            <li id="reference_6">
              <a
                target="_blank"
                href="https://www.serverless.com/aws-step-functions#drawbacks"
                >AWS Step Functions - The Ultimate Guide</a
              >
            </li>
            <li id="reference_7">
              <a
                target="_blank"
                href="https://acloud.guru/series/serverlessconf-nyc-2019/view/yaml-better?_hsenc=p2ANqtz-8NTIqitxWIiUw-zP8PduvB33SIKeFTL96OW8aFES-aovT2WN3ULwZm_cXSRpmntdO4cF6Z"
                >YAML Is Better than Your Favorite Language: Fightin' words
                about Infrastructure as code | Ben Kehoe</a
              >
            </li>
            <li id="reference_8">
              <a target="_blank" href="https://aws.amazon.com/cloudformation/"
                >AWS Cloud Formation</a
              >
            </li>
            <li id="reference_9">
              <a
                target="_blank"
                href="https://aws.amazon.com/getting-started/tools-sdks/"
                >Start building with SDKs and tools</a
              >
            </li>
            <li id="reference_10">
              <a target="_blank" href="https://www.serverless.com/"
                >Serverless Framework</a
              >
            </li>
            <li id="reference_11">
              <a target="_blank" href="https://aws.amazon.com/serverless/sam/"
                >AWS Serverless Application Model</a
              >
            </li>
            <li id="reference_12">
              <a target="_blank" href="https://github.com/coinbase/step"
                >Step</a
              >
            </li>
            <li id="reference_13">
              <a
                target="_blank"
                href="https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html"
                >What is IAM?</a
              >
            </li>
            <li id="reference_14">
              <a
                target="_blank"
                href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await"
                >Async / await</a
              >
            </li>
            <li>
              <a target="_blank" href="https://arxiv.org/pdf/1807.11248.pdf"
                >Comparison of FaaS Orchestration Systems</a
              >
            </li>
            <li>
              <a target="_blank" href="https://www.ibm.com/cloud/learn/faas"
                >FaaS</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://medium.com/serverless-transformation/serverless-event-scheduling-using-aws-step-functions-b4f24997c8e2"
                >Serverless Event Scheduling — Using AWS Step Functions</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://www.cloudflare.com/learning/serverless/glossary/serverless-vs-paas/"
                >How are serverless computing and Platform-as-a-Service
                different?</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://aws.amazon.com/solutions/case-studies/the-guardian/"
                >Guardian News &amp; Media Automates Subscription Fulfillment
                Using AWS Step Functions</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://medium.com/@scott_triglia/building-self-healing-observable-systems-with-aws-step-functions-8fe5b402ef7e"
                >Building self-healing, observable systems with AWS Step
                Functions</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://medium.com/weareservian/aws-step-functions-the-power-of-simplicity-10e8395af4f3"
                >AWS Step Functions - The Power of Simplicity</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://engineeringblog.yelp.com/2017/11/breaking-down-the-monolith-with-aws-step-functions.html"
                >Breaking down the monolith with AWS Step Functions</a
              >
            </li>
            <li>
              <a target="_blank" href="https://github.com/sosw/sosw">SOSW</a>
            </li>
            <li>
              <a
                target="_blank"
                href="https://medium.com/a-tale-of-2-from-data-to-information/serverless-smart-radio-1cabcab8de30"
                >Serverless Smart Radio</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9"
                >What is Serverless Architecture? What are its Pros and Cons?</a
              >
            </li>
            <li>
              <a target="_blank" href="https://aws.amazon.com/what-is-aws/"
                >What is AWS?</a
              >
            </li>
            <li>
              <a
                href="https://www.youtube.com/watch?v=bEB0zDHXXG4&feature=youtu.be"
                target="_blank"
                >Youtube tutorial for deploying with Serverless Framework</a
              >
            </li>
          </ol>
        </section>
      </section>
    </main>
    <section id="our-team">
      <img
        src="assets/images/logos/maestro/mark-on-light.png"
        alt="Maestro logo"
      />
      <h1>Our Team</h1>
      <p>
        We are looking for opportunities. If you liked what you saw and want to
        talk more, please reach out!
      </p>
      <ul>
        <li class="individual">
          <a href="https://t-monius.github.io/" target="_blank"
            ><img
              src="assets/images/team/torrel_moseley.jpg"
              alt="Torrel Moseley"
          /></a>
          <h3>Torrel Moseley</h3>
          <p>NYC &amp; Denver</p>
          <ul class="social-icons">
            <li>
              <a href="mailto:trrl.mo&commat;hotmail.com" target="_blank"
                ><img src="assets/images/icons/email_icon.png" alt="email"
              /></a>
            </li>
            <li>
              <a href="https://t-monius.github.io/" target="_blank"
                ><img src="assets/images/icons/website_icon.png" alt="website"
              /></a>
            </li>
            <li>
              <a
                href="https://www.linkedin.com/in/torrelmoseley/"
                target="_blank"
                ><img
                  src="assets/images/icons/linkedin_icon.png"
                  alt="linkedin_icon"
              /></a>
            </li>
          </ul>
        </li>
        <li class="individual">
          <a href="https://zklamm.github.io/" target="_blank">
            <img src="assets/images/team/zac_klammer.jpg" alt="Zac Klammer" />
          </a>
          <h3>Zac Klammer</h3>
          <p>Corpus Christi, TX</p>
          <ul class="social-icons">
            <li>
              <a href="mailto:zklamm&commat;gmail.com" target="_blank"
                ><img src="assets/images/icons/email_icon.png" alt="email"
              /></a>
            </li>
            <li>
              <a href="https://zklamm.github.io/" target="_blank"
                ><img src="assets/images/icons/website_icon.png" alt="website"
              /></a>
            </li>
            <li>
              <a
                href="https://www.linkedin.com/in/zac-klammer-b4b7741b/"
                target="_blank"
                ><img
                  src="assets/images/icons/linkedin_icon.png"
                  alt="linkedin"
              /></a>
            </li>
          </ul>
        </li>
        <li class="individual">
          <a href="https://johnisom.dev/" target="_blank">
            <img
              src="assets/images/team/john_isom.jpg"
              alt="Picture of John Isom"
          /></a>
          <h3>John Isom</h3>

          <p>NYC & Salt Lake City</p>
          <ul class="social-icons">
            <li>
              <a href="mailto:john&commat;johnisom.dev" target="_blank"
                ><img src="assets/images/icons/email_icon.png" alt="email"
              /></a>
            </li>
            <li>
              <a href="https://johnisom.dev/" target="_blank"
                ><img src="assets/images/icons/website_icon.png" alt="website"
              /></a>
            </li>
            <li>
              <a href="https://linkedin.com/in/john-isom/" target="_blank"
                ><img
                  src="assets/images/icons/linkedin_icon.png"
                  alt="linkedin"
              /></a>
            </li>
          </ul>
        </li>
      </ul>
    </section>
  </body>
</html>
